{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 49,
   "id": "d424ebce",
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "import tensorflow as tf\n",
    "from tensorflow.keras import layers, models\n",
    "from sklearn.model_selection import train_test_split\n",
    "from sklearn.preprocessing import LabelEncoder\n",
    "import pandas as pd\n",
    "from astroquery.vizier import Vizier\n",
    "import cv2 "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 50,
   "id": "e521810c",
   "metadata": {},
   "outputs": [],
   "source": [
    "def catalog():\n",
    "    \"\"\"Загружаем каталог звезд\"\"\"\n",
    "    try:\n",
    "        Vizier.ROW_LIMIT = 1000\n",
    "        catalogs = [\"B/gcvs/gcvs_cat\", \"J/A+A/618/A110/catalog\", \"II/250A/asassn\"]\n",
    "        \n",
    "        all_data = []\n",
    "        for catalog_name in catalogs:\n",
    "            try:\n",
    "                result = Vizier.get_catalogs(catalog_name)\n",
    "                if result:\n",
    "                    df = result[0].to_pandas()\n",
    "                    df['Catalog'] = catalog_name\n",
    "                    all_data.append(df)\n",
    "                    print(f\"Загружено {len(df)} звезд из {catalog_name}\")\n",
    "            except:\n",
    "                continue\n",
    "        \n",
    "        if all_data:\n",
    "            combined_df = pd.concat(all_data, ignore_index=True)\n",
    "            print(f\"Всего звезд: {len(combined_df)}\")\n",
    "            return combined_df\n",
    "        return None\n",
    "        \n",
    "    except Exception as e:\n",
    "        print(f\"Ошибка: {e}\")\n",
    "        return None"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 51,
   "id": "2449a5a4",
   "metadata": {},
   "outputs": [],
   "source": [
    "def krivaya(star_type, period, amplitude, num_points=500):\n",
    "    \"\"\"Генерируем кривую блеска\"\"\"\n",
    "    phases = np.linspace(0, 2, num_points)\n",
    "    amp = min(amplitude, 3.0)\n",
    "    \n",
    "    if star_type.upper() in ['EA', 'ECL', 'Algol']:\n",
    "        primary = amp * np.exp(-((phases % 1 - 0.0)**2) / 0.0015)\n",
    "        secondary = 0.3 * amp * np.exp(-((phases % 1 - 0.5)**2) / 0.002)\n",
    "        curve = primary + secondary\n",
    "        \n",
    "    elif star_type.upper() in ['EB', 'BetaLyrae', 'LYR']:\n",
    "        main = 0.7 * amp * (1 - np.cos(2 * np.pi * phases))\n",
    "        harmonic = 0.3 * amp * (1 - np.cos(4 * np.pi * phases + 0.5))\n",
    "        curve = main + harmonic\n",
    "        \n",
    "    elif star_type.upper() in ['EW', 'WUMa', 'Contact']:\n",
    "        curve = 0.8 * amp * np.sin(np.pi * phases)**3\n",
    "        \n",
    "    elif star_type.upper() in ['RR', 'RRab', 'RRc', 'RRLyr']:\n",
    "        curve = amp * np.sin(2 * np.pi * phases + 0.7)**2.5 if 'RRab' in star_type.upper() else 0.6 * amp * np.sin(2 * np.pi * phases)**1.5\n",
    "            \n",
    "    elif star_type.upper() in ['DCEP', 'CEP', 'Cepheid']:\n",
    "        curve = amp * (0.7 * np.sin(2 * np.pi * phases) + 0.3 * np.sin(4 * np.pi * phases + 1.2))\n",
    "        \n",
    "    elif star_type.upper() in ['DSCT', 'DeltaScuti', 'SCT']:\n",
    "        curve = (0.1 * amp * np.sin(2 * np.pi * phases) + 0.05 * amp * np.sin(4 * np.pi * phases + 0.7))\n",
    "        \n",
    "    elif star_type.upper() in ['MIRA', 'M', 'LPV']:\n",
    "        curve = amp * (0.8 * np.sin(2 * np.pi * phases) + 0.2 * np.sin(4 * np.pi * phases))\n",
    "        \n",
    "    else:\n",
    "        curve = 0.5 * amp * np.sin(2 * np.pi * phases)\n",
    "    \n",
    "    curve += np.random.normal(0, 0.02, len(phases))\n",
    "    return phases, curve"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 52,
   "id": "5c93da5d",
   "metadata": {},
   "outputs": [],
   "source": [
    "def predict_star_type_from_image(image_path, model, label_encoder):\n",
    "    \"\"\"Предсказывает тип звезды по изображению кривой блеска\"\"\"\n",
    "    # Загрузка и предобработка изображения\n",
    "    img = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)\n",
    "    img = cv2.resize(img, (100, 1))  # Преобразуем к размеру 1x100\n",
    "    img = img.astype('float32') / 255.0  # Нормализация\n",
    "    \n",
    "    # Предсказание\n",
    "    prediction = model.predict(img.reshape(1, -1), verbose=0)\n",
    "    predicted_class = np.argmax(prediction)\n",
    "    confidence = np.max(prediction)\n",
    "    \n",
    "    star_type = label_encoder.inverse_transform([predicted_class])[0]\n",
    "    \n",
    "    return star_type, confidence"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 53,
   "id": "cb6dca20",
   "metadata": {},
   "outputs": [],
   "source": [
    "def model(input_size, num_classes):\n",
    "    \"\"\"Создаем модель нейросети\"\"\"\n",
    "    model = models.Sequential([\n",
    "        layers.Dense(64, activation='relu', input_shape=(input_size,)),\n",
    "        layers.Dropout(0.3),\n",
    "        layers.Dense(32, activation='relu'),\n",
    "        layers.Dropout(0.2),\n",
    "        layers.Dense(num_classes, activation='softmax')\n",
    "    ])\n",
    "    \n",
    "    model.compile(optimizer='adam',\n",
    "                  loss='sparse_categorical_crossentropy',\n",
    "                  metrics=['accuracy'])\n",
    "    return model"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 54,
   "id": "166f3b24",
   "metadata": {},
   "outputs": [],
   "source": [
    "def prepare_data(samples_per_type=200):\n",
    "    \"\"\"Подготавливаем данные для обучения\"\"\"\n",
    "    print(\"Загружаем каталог...\")\n",
    "    catalog_data = catalog()\n",
    "    \n",
    "   \n",
    "    curves = []\n",
    "    labels = []\n",
    "    \n",
    "    type_col = 'Type' if 'Type' in catalog_data.columns else 'VarType' if 'VarType' in catalog_data.columns else None\n",
    "    \n",
    "   \n",
    "    \n",
    "    star_types = catalog_data[type_col].value_counts().head(7).index.tolist()\n",
    "    print(f\"Типы звезд: {star_types}\")\n",
    "    \n",
    "    for star_type in star_types:\n",
    "        stars_of_type = catalog_data[catalog_data[type_col] == star_type]\n",
    "        print(f\"Обрабатываем {len(stars_of_type)} звезд типа {star_type}...\")\n",
    "        \n",
    "        for _, star in stars_of_type.head(samples_per_type).iterrows():\n",
    "            try:\n",
    "                period = star.get('Period', np.random.uniform(0.1, 100))\n",
    "                amplitude = star.get('Amplitude', np.random.uniform(0.1, 3.0))\n",
    "                \n",
    "                phases, curve = krivaya(star_type, period, amplitude, 100)\n",
    "                curve = (curve - np.mean(curve)) / np.std(curve)\n",
    "                \n",
    "                curves.append(curve)\n",
    "                labels.append(star_type)\n",
    "            except:\n",
    "                continue\n",
    "    \n",
    "    return np.array(curves), np.array(labels)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 55,
   "id": "c7a177c8",
   "metadata": {},
   "outputs": [],
   "source": [
    "def main():\n",
    "    \"\"\"Основная функция\"\"\"\n",
    "    print(\"=== КЛАССИФИКАТОР ПЕРЕМЕННЫХ ЗВЕЗД ===\\n\")\n",
    "    \n",
    "    print(\"1. Подготовка данных...\")\n",
    "    X, y = prepare_data(150)\n",
    "    \n",
    "    if len(X) == 0:\n",
    "        print(\"Не удалось подготовить данные\")\n",
    "        return\n",
    "    \n",
    "    encoder = LabelEncoder()\n",
    "    y_encoded = encoder.fit_transform(y)\n",
    "    \n",
    "    X_train, X_test, y_train, y_test = train_test_split(X, y_encoded, test_size=0.2, random_state=42)\n",
    "    \n",
    "    print(f\"Обучающая выборка: {X_train.shape}\")\n",
    "    print(f\"Тестовая выборка: {X_test.shape}\")\n",
    "    print(f\"Классы: {list(encoder.classes_)}\")\n",
    "    \n",
    "    print(\"\\n2. Обучаем модель...\")\n",
    "    nn_model = model(X.shape[1], len(encoder.classes_))\n",
    "    \n",
    "    history = nn_model.fit(\n",
    "        X_train, y_train,\n",
    "        epochs=30,\n",
    "        batch_size=32,\n",
    "        validation_data=(X_test, y_test),\n",
    "        verbose=1\n",
    "    )\n",
    "    \n",
    "    print(\"\\n3. Проверяем модель...\")\n",
    "    test_loss, test_acc = nn_model.evaluate(X_test, y_test, verbose=0)\n",
    "    print(f\"Точность: {test_acc:.4f}\")\n",
    "    \n",
    "    return nn_model, encoder"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 56,
   "id": "8e48d162",
   "metadata": {},
   "outputs": [],
   "source": [
    "def classify_star(image_path):\n",
    "        \"\"\"Функция для классификации звезды по изображению\"\"\"\n",
    "        star_type, confidence = predict_star_type_from_image(image_path, model, encoder)\n",
    "        return f\"Тип звезды: ({star_type})\""
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 57,
   "id": "c78b5ee5",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "=== КЛАССИФИКАТОР ПЕРЕМЕННЫХ ЗВЕЗД ===\n",
      "\n",
      "1. Подготовка данных...\n",
      "Загружаем каталог...\n",
      "Загружено 1000 звезд из B/gcvs/gcvs_cat\n",
      "Всего звезд: 1000\n",
      "Типы звезд: ['EW', 'EA', 'LB', 'M', 'RRAB', 'EB', 'SRB']\n",
      "Обрабатываем 127 звезд типа EW...\n",
      "Обрабатываем 115 звезд типа EA...\n",
      "Обрабатываем 113 звезд типа LB...\n",
      "Обрабатываем 84 звезд типа M...\n",
      "Обрабатываем 70 звезд типа RRAB...\n",
      "Обрабатываем 56 звезд типа EB...\n",
      "Обрабатываем 45 звезд типа SRB...\n",
      "Обучающая выборка: (488, 100)\n",
      "Тестовая выборка: (122, 100)\n",
      "Классы: ['EA', 'EB', 'EW', 'LB', 'M', 'RRAB', 'SRB']\n",
      "\n",
      "2. Обучаем модель...\n",
      "Epoch 1/30\n",
      "16/16 [==============================] - 1s 18ms/step - loss: 1.7392 - accuracy: 0.3135 - val_loss: 1.1620 - val_accuracy: 0.6721\n",
      "Epoch 2/30\n",
      "16/16 [==============================] - 0s 5ms/step - loss: 1.1079 - accuracy: 0.6311 - val_loss: 0.7734 - val_accuracy: 0.7459\n",
      "Epoch 3/30\n",
      "16/16 [==============================] - 0s 5ms/step - loss: 0.8598 - accuracy: 0.6660 - val_loss: 0.6600 - val_accuracy: 0.8197\n",
      "Epoch 4/30\n",
      "16/16 [==============================] - 0s 5ms/step - loss: 0.7625 - accuracy: 0.7090 - val_loss: 0.5964 - val_accuracy: 0.8197\n",
      "Epoch 5/30\n",
      "16/16 [==============================] - 0s 5ms/step - loss: 0.7349 - accuracy: 0.7152 - val_loss: 0.5664 - val_accuracy: 0.8197\n",
      "Epoch 6/30\n",
      "16/16 [==============================] - 0s 5ms/step - loss: 0.6848 - accuracy: 0.7295 - val_loss: 0.5390 - val_accuracy: 0.8197\n",
      "Epoch 7/30\n",
      "16/16 [==============================] - 0s 5ms/step - loss: 0.6715 - accuracy: 0.7377 - val_loss: 0.5000 - val_accuracy: 0.8197\n",
      "Epoch 8/30\n",
      "16/16 [==============================] - 0s 5ms/step - loss: 0.6279 - accuracy: 0.7418 - val_loss: 0.4779 - val_accuracy: 0.8197\n",
      "Epoch 9/30\n",
      "16/16 [==============================] - 0s 5ms/step - loss: 0.5724 - accuracy: 0.7643 - val_loss: 0.4494 - val_accuracy: 0.8197\n",
      "Epoch 10/30\n",
      "16/16 [==============================] - 0s 5ms/step - loss: 0.5371 - accuracy: 0.8033 - val_loss: 0.4211 - val_accuracy: 0.8197\n",
      "Epoch 11/30\n",
      "16/16 [==============================] - 0s 5ms/step - loss: 0.5526 - accuracy: 0.7787 - val_loss: 0.4102 - val_accuracy: 0.8197\n",
      "Epoch 12/30\n",
      "16/16 [==============================] - 0s 5ms/step - loss: 0.5240 - accuracy: 0.7766 - val_loss: 0.3958 - val_accuracy: 0.8197\n",
      "Epoch 13/30\n",
      "16/16 [==============================] - 0s 5ms/step - loss: 0.4824 - accuracy: 0.7971 - val_loss: 0.3921 - val_accuracy: 0.8197\n",
      "Epoch 14/30\n",
      "16/16 [==============================] - 0s 5ms/step - loss: 0.4921 - accuracy: 0.7930 - val_loss: 0.3814 - val_accuracy: 0.8197\n",
      "Epoch 15/30\n",
      "16/16 [==============================] - 0s 5ms/step - loss: 0.4847 - accuracy: 0.7643 - val_loss: 0.3868 - val_accuracy: 0.8279\n",
      "Epoch 16/30\n",
      "16/16 [==============================] - 0s 6ms/step - loss: 0.4757 - accuracy: 0.7664 - val_loss: 0.3744 - val_accuracy: 0.8197\n",
      "Epoch 17/30\n",
      "16/16 [==============================] - 0s 5ms/step - loss: 0.4549 - accuracy: 0.7910 - val_loss: 0.3733 - val_accuracy: 0.8197\n",
      "Epoch 18/30\n",
      "16/16 [==============================] - 0s 6ms/step - loss: 0.4522 - accuracy: 0.8033 - val_loss: 0.3694 - val_accuracy: 0.8197\n",
      "Epoch 19/30\n",
      "16/16 [==============================] - 0s 5ms/step - loss: 0.4442 - accuracy: 0.7746 - val_loss: 0.3672 - val_accuracy: 0.8197\n",
      "Epoch 20/30\n",
      "16/16 [==============================] - 0s 5ms/step - loss: 0.4502 - accuracy: 0.7746 - val_loss: 0.3696 - val_accuracy: 0.8197\n",
      "Epoch 21/30\n",
      "16/16 [==============================] - 0s 5ms/step - loss: 0.4344 - accuracy: 0.7951 - val_loss: 0.3784 - val_accuracy: 0.8197\n",
      "Epoch 22/30\n",
      "16/16 [==============================] - 0s 6ms/step - loss: 0.4388 - accuracy: 0.7807 - val_loss: 0.3672 - val_accuracy: 0.8197\n",
      "Epoch 23/30\n",
      "16/16 [==============================] - 0s 5ms/step - loss: 0.4337 - accuracy: 0.8074 - val_loss: 0.3703 - val_accuracy: 0.8197\n",
      "Epoch 24/30\n",
      "16/16 [==============================] - 0s 5ms/step - loss: 0.4322 - accuracy: 0.8033 - val_loss: 0.3720 - val_accuracy: 0.8197\n",
      "Epoch 25/30\n",
      "16/16 [==============================] - 0s 6ms/step - loss: 0.4093 - accuracy: 0.8115 - val_loss: 0.3736 - val_accuracy: 0.8197\n",
      "Epoch 26/30\n",
      "16/16 [==============================] - 0s 5ms/step - loss: 0.4282 - accuracy: 0.7910 - val_loss: 0.3654 - val_accuracy: 0.8197\n",
      "Epoch 27/30\n",
      "16/16 [==============================] - 0s 6ms/step - loss: 0.4134 - accuracy: 0.8135 - val_loss: 0.3638 - val_accuracy: 0.8197\n",
      "Epoch 28/30\n",
      "16/16 [==============================] - 0s 5ms/step - loss: 0.4177 - accuracy: 0.7971 - val_loss: 0.3683 - val_accuracy: 0.8197\n",
      "Epoch 29/30\n",
      "16/16 [==============================] - 0s 5ms/step - loss: 0.4343 - accuracy: 0.8033 - val_loss: 0.3664 - val_accuracy: 0.8197\n",
      "Epoch 30/30\n",
      "16/16 [==============================] - 0s 5ms/step - loss: 0.4101 - accuracy: 0.8156 - val_loss: 0.3641 - val_accuracy: 0.8197\n",
      "\n",
      "3. Проверяем модель...\n",
      "Точность: 0.8197\n",
      "\n",
      "==================================================\n",
      "Готово! Модель обучена.\n"
     ]
    }
   ],
   "source": [
    "if __name__ == \"__main__\":\n",
    "    model, encoder = main()\n",
    "    \n",
    "    print(\"\\n\" + \"=\"*50)\n",
    "    print(\"Готово! Модель обучена.\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 58,
   "id": "693f2908",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "'Тип звезды: (RRAB)'"
      ]
     },
     "execution_count": 58,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "classify_star('C:/Users/rosen/Desktop/COVID_analysys/bezyman.png')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "c62e404d",
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "da8d7ee3",
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "6c16bc7a",
   "metadata": {},
   "outputs": [],
   "source": [
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "dab9617c",
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "49be62c7",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.10.9"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
